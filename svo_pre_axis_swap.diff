diff --git a/imgui.ini b/imgui.ini
index 4a5c201..e7f5743 100644
--- a/imgui.ini
+++ b/imgui.ini
@@ -3,3 +3,8 @@ Pos=60,60
 Size=400,400
 Collapsed=0
 
+[Window][Options]
+Pos=60,60
+Size=152,215
+Collapsed=0
+
diff --git a/src/Octree.cpp b/src/Octree.cpp
index 07a841b..6bcb860 100644
--- a/src/Octree.cpp
+++ b/src/Octree.cpp
@@ -51,7 +51,11 @@ Octree::Octree()
     //     0x00008200, 0x00008200, 0x00008200, 0x00008200,
     //     0x00008200, 0x00008200, 0x00008200, 0x00008200,
     // };
-    Generate();
+
+    // Generate();
+
+    _treeSize = 1;
+    _tree = {0x00001F00};
 }
 
 void Octree::Generate()
@@ -191,26 +195,39 @@ bool Octree::Raymarch(glm::vec3 &ro,
         {
             if (maxTC * rayScale >= scaleExp2)
             {
+#if 0
                 // Testing return value
                 // Hit
-                r_hit.x = ro.x + (minT * rd.x);
-                r_hit.y = ro.x + (minT * rd.x);
-                r_hit.z = ro.x + (minT * rd.x);
+                // r_hit.x = ro.x + (minT * rd.x);
+                // r_hit.y = ro.x + (minT * rd.x);
+                // r_hit.z = ro.x + (minT * rd.x);
+                r_hit.x = std::min(std::max(ro.x + minT * rd.x, posX + 1e-4f), posX + scaleExp2 - 1e-4f);
+                r_hit.y = std::min(std::max(ro.y + minT * rd.y, posY + 1e-4f), posY + scaleExp2 - 1e-4f);
+                r_hit.z = std::min(std::max(ro.z + minT * rd.z, posZ + 1e-4f), posZ + scaleExp2 - 1e-4f);
 
                 // Normal
                 glm::vec3 t_corner;
-                t_corner.x = dTx * (ro.x + scaleExp2) - bTx;
-                t_corner.y = dTy * (ro.y + scaleExp2) - bTy;
-                t_corner.z = dTz * (ro.z + scaleExp2) - bTz;
-                int x = int(t_corner.x > t_corner.y && t_corner.x > t_corner.z);
-                int y = int(x == 0 && t_corner.y > t_corner.z);
-                int z = int(x == 0 && y == 0);
-                glm::vec3 mask = glm::vec3(
-                    int((octantMask & 1u) == 0u),
-                    int((octantMask & 2u) == 0u),
-                    int((octantMask & 4u) == 0u));
-                mask = (mask * 2.0f) - 1.0f;
-                r_normal = mask * glm::vec3(x, y, z);
+                t_corner.x = dTx * (posX + scaleExp2) - bTx;
+                t_corner.y = dTy * (posY + scaleExp2) - bTy;
+                t_corner.z = dTz * (posZ + scaleExp2) - bTz;
+                if (t_corner.x > t_corner.y && t_corner.x > t_corner.z)
+                {
+                    r_normal = glm::vec3(-1, 0, 0);
+                }
+                else if (t_corner.y > t_corner.z)
+                {
+                    r_normal = glm::vec3(0, -1, 0);
+                }
+                else
+                {
+                    r_normal = glm::vec3(0, 0, -1);
+                }
+                if ((octantMask & 1u) == 0u)
+                    r_normal.x = -r_normal.x;
+                if ((octantMask & 2u) == 0u)
+                    r_normal.y = -r_normal.y;
+                if ((octantMask & 4u) == 0u)
+                    r_normal.z = -r_normal.z;
                 // r_normal = glm::normalize(r_normal);
 
                 // Depth
@@ -219,6 +236,8 @@ bool Octree::Raymarch(glm::vec3 &ro,
                 // Index
                 r_idx = idx ^ octantMask ^ 7;
                 return true;
+#endif
+                break;
             }
 
             float maxTV = std::min(maxT, maxTC);
@@ -304,25 +323,37 @@ bool Octree::Raymarch(glm::vec3 &ro,
 
     // Testing return value
     // Hit
-    r_hit.x = ro.x + (minT * rd.x);
-    r_hit.y = ro.x + (minT * rd.x);
-    r_hit.z = ro.x + (minT * rd.x);
+    // r_hit.x = ro.x + (minT * rd.x);
+    // r_hit.y = ro.x + (minT * rd.x);
+    // r_hit.z = ro.x + (minT * rd.x);
+    r_hit.x = std::min(std::max(ro.x + minT * rd.x, posX + 1e-4f), posX + scaleExp2 - 1e-4f);
+    r_hit.y = std::min(std::max(ro.y + minT * rd.y, posY + 1e-4f), posY + scaleExp2 - 1e-4f);
+    r_hit.z = std::min(std::max(ro.z + minT * rd.z, posZ + 1e-4f), posZ + scaleExp2 - 1e-4f);
 
     // Normal
     glm::vec3 t_corner;
-    t_corner.x = dTx * (ro.x + scaleExp2) - bTx;
-    t_corner.y = dTy * (ro.y + scaleExp2) - bTy;
-    t_corner.z = dTz * (ro.z + scaleExp2) - bTz;
-    int x = int(t_corner.x > t_corner.y && t_corner.x > t_corner.z);
-    int y = int(x == 0 && t_corner.y > t_corner.z);
-    int z = int(x == 0 && y == 0);
-    glm::vec3 mask = glm::vec3(
-        int((octantMask & 1u) == 0u),
-        int((octantMask & 2u) == 0u),
-        int((octantMask & 4u) == 0u));
-    mask = (mask * 2.0f) - 1.0f;
-    r_normal = mask * glm::vec3(x, y, z);
-    r_normal = glm::normalize(r_normal);
+    t_corner.x = dTx * (posX + scaleExp2) - bTx;
+    t_corner.y = dTy * (posY + scaleExp2) - bTy;
+    t_corner.z = dTz * (posZ + scaleExp2) - bTz;
+    if (t_corner.x > t_corner.y && t_corner.x > t_corner.z)
+    {
+        r_normal = glm::vec3(-1, 0, 0);
+    }
+    else if (t_corner.y > t_corner.z)
+    {
+        r_normal = glm::vec3(0, -1, 0);
+    }
+    else
+    {
+        r_normal = glm::vec3(0, 0, -1);
+    }
+    if ((octantMask & 1u) == 0u)
+        r_normal.x = -r_normal.x;
+    if ((octantMask & 2u) == 0u)
+        r_normal.y = -r_normal.y;
+    if ((octantMask & 4u) == 0u)
+        r_normal.z = -r_normal.z;
+    // r_normal = glm::normalize(r_normal);
 
     // Depth
     r_depth = minT;
@@ -332,8 +363,12 @@ bool Octree::Raymarch(glm::vec3 &ro,
     return true;
 }
 
-void Octree::DrawOctree(uint32_t vwidth, uint32_t vheight, float vwidthf, float vheightf, Pixel *buffer, float time)
+void Octree::DrawOctree(uint32_t vwidth, uint32_t vheight, float vwidthf, float vheightf, Pixel *buffer, float *depthBuffer, float time)
 {
+    // Light
+    glm::vec3 p0 = LightPos - LightSize;
+    glm::vec3 p1 = LightPos + LightSize;
+
     // Rotation
     glm::mat4 trans = glm::mat4(1.0f);
     trans = glm::rotate(trans, glm::radians(Rotation), glm::vec3(0.0f, 1.0f, 0.0f));
@@ -344,6 +379,7 @@ void Octree::DrawOctree(uint32_t vwidth, uint32_t vheight, float vwidthf, float
 
     float rx, ry;
     glm::vec3 pos;
+    glm::vec3 octreeRayOrigin;
     glm::vec3 rayOrigin;
     glm::vec3 rayDirection;
 
@@ -368,16 +404,24 @@ void Octree::DrawOctree(uint32_t vwidth, uint32_t vheight, float vwidthf, float
             // rayDirection = cameraDir;
 
             // Perspective:
-            rayOrigin = cameraPos - OctreeLoc;
+            rayOrigin = cameraPos;
+            octreeRayOrigin = cameraPos - OctreeLoc;
             rayDirection = cameraDir + pos;
 
             index = x + (y * vwidth);
-            if (Raymarch(rayOrigin, rayDirection, hit, normal, idx, depth))
+            if (Raymarch(octreeRayOrigin, rayDirection, hit, normal, idx, depth))
             {
-                // buffer[index] = shadeDepth(objectColor, depth);
+                // buffer[index] = ShadeDepth(ObjectColor, depth);
                 // buffer[index] = colors[idx];
                 hit += OctreeLoc;
                 buffer[index] = Shade(cameraPos, LightColor, LightPos, ObjectColor, normal, hit);
+                depthBuffer[index] = depth;
+            }
+            else if (slabs(p0, p1, rayOrigin, rayDirection))
+            {
+                buffer[index].r = (uint32_t)(LightColor.r * 255.0f);
+                buffer[index].g = (uint32_t)(LightColor.g * 255.0f);
+                buffer[index].b = (uint32_t)(LightColor.b * 255.0f);
             }
             else
             {
@@ -422,4 +466,15 @@ Pixel Octree::ShadeDepth(glm::vec3 &objectColor, float &depth)
     result.g = (uint32_t)(objectColor.g * 255.0f * (depth / 2.0f));
     result.b = (uint32_t)(objectColor.b * 255.0f);
     return result;
+}
+
+bool Octree::slabs(glm::vec3 &p0, glm::vec3 &p1, glm::vec3 &ro, glm::vec3 &rd)
+{
+    glm::vec3 invRd = 1.0f / rd;
+    glm::vec3 t0 = (p0 - ro) * invRd;
+    glm::vec3 t1 = (p1 - ro) * invRd;
+    glm::vec3 tmin = glm::min(t0, t1);
+    glm::vec3 tmax = glm::max(t0, t1);
+
+    return std::max(std::max(tmin.x, tmin.y), tmin.z) <= std::min(std::min(tmax.x, tmax.y), tmax.z);
 }
\ No newline at end of file
diff --git a/src/Octree.hpp b/src/Octree.hpp
index 565695f..3f9edee 100644
--- a/src/Octree.hpp
+++ b/src/Octree.hpp
@@ -23,6 +23,7 @@ public:
     // Lighting
     glm::vec3 LightColor = glm::vec3(1.0f);
     glm::vec3 LightPos = glm::vec3(0.0f, 0.0f, -1.5f);
+    float LightSize = 0.05f;
     glm::vec3 ObjectColor = glm::vec3(0.0f, 1.0f, 0.0f);
 
     // Rotation
@@ -32,7 +33,7 @@ public:
 
     void Generate();
 
-    void DrawOctree(uint32_t vwidth, uint32_t vheight, float vwidthf, float vheightf, Pixel *buffer, float time);
+    void DrawOctree(uint32_t vwidth, uint32_t vheight, float vwidthf, float vheightf, Pixel *buffer, float *depthBuffer, float time);
 
     bool Raymarch(glm::vec3 &ro,
                   glm::vec3 &rd,
@@ -49,6 +50,8 @@ private:
     Pixel Shade(glm::vec3 &cameraPos, glm::vec3 &lightColor, glm::vec3 lightPos, glm::vec3 &objectColor, glm::vec3 &normal, glm::vec3 &hitPos);
     Pixel ShadeDepth(glm::vec3 &objectColor, float &depth);
 
+    bool slabs(glm::vec3 &p0, glm::vec3 &p1, glm::vec3 &ro, glm::vec3 &rd);
+
     static inline float uintBitsToFloat(uint32_t i)
     {
         union
diff --git a/src/Window.cpp b/src/Window.cpp
index c0dd93e..9eb6ea7 100644
--- a/src/Window.cpp
+++ b/src/Window.cpp
@@ -23,6 +23,9 @@ Window::Window(uint32_t width, uint32_t height, uint32_t vwidth, uint32_t vheigh
     _vratio = float(vwidth) / float(vheight);
     _pixels = _vwidth * _vheight;
     buffer = new Pixel[_pixels];
+
+    depthBuffer = new float[_pixels];
+    std::fill_n(depthBuffer, _pixels, FLT_MAX);
 }
 
 void Window::Setup()
@@ -161,10 +164,11 @@ void Window::DrawUI(Octree *octree)
     ImGui::SliderFloat3("Octree Position", glm::value_ptr(octree->OctreeLoc), -5.0f, 5.0f);
     ImGui::SliderFloat3("Octree Color", glm::value_ptr(octree->ObjectColor), 0.0f, 1.0f);
     ImGui::SliderFloat3("Light Position", glm::value_ptr(octree->LightPos), -5.0f, 5.0f);
+    ImGui::SliderFloat("Light Size", &octree->LightSize, 0.0f, 2.0f);
     ImGui::SliderFloat3("Light Color", glm::value_ptr(octree->LightColor), 0.0f, 1.0f);
-    if (ImGui::Button("Refresh Octree"))
+    if (ImGui::Button("Refresh"))
     {
-        octree->DrawOctree(_vwidth, _vheight, _vwidthf, _vheightf, buffer, (float)glfwGetTime());
+        octree->DrawOctree(_vwidth, _vheight, _vwidthf, _vheightf, buffer, depthBuffer, (float)glfwGetTime());
     }
     ImGui::End();
 
@@ -206,6 +210,7 @@ void Window::Exit()
     glfwTerminate();
 
     delete[] buffer;
+    delete[] depthBuffer;
 }
 
 void Window::Resize(uint32_t width, uint32_t height)
diff --git a/src/Window.hpp b/src/Window.hpp
index 66f88b7..44ac32b 100644
--- a/src/Window.hpp
+++ b/src/Window.hpp
@@ -10,6 +10,7 @@
 #include <glm/gtx/rotate_vector.hpp>
 
 #include <memory>
+#include <algorithm>
 
 #include "Util.hpp"
 #include "Octree.hpp"
@@ -26,6 +27,7 @@ public:
 
 public:
     Pixel *buffer;
+    float *depthBuffer;
 
 private:
     void DrawUI(Octree *octree);
